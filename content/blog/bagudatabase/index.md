---
title: 数据库八股
summary: 笔面试中有关数据库的八股试题整理
date: 2025-12-01

# Featured image
# Place an image named `featured.jpg/png` in this page's folder and customize its options here.


authors:
  - admin


tags:
  - 数据库
  - 八股

---



{{< toc mobile_only=true is_open=true >}}



## 索引
```sql
CREATE INDEX idx_name ON users(name); -- 为 'users' 表中的 'name' 列创建普通索引
ALTER TABLE users ADD PRIMARY KEY (id); -- 为 'users' 表的主键 'id' 添加主键索引
CREATE UNIQUE INDEX idx_email ON users(email); -- 为 'users' 表的 'email' 列创建唯一索引
```

### B+树&哈希索引
**B+树索引**
   **特点**：B-Tree是最常见的索引类型，几乎所有的存储引擎都支持这种索引。它基于平衡二叉树的数据结构，能够高效地进行范围查询和精确查找。
   **适用场景**：
      1. **范围查询**：B+树索引非常适合用于处理范围查询，比如`WHERE col2 > 10 AND col2 < 20`这样的条件。因为B+树的特性是按顺序存储数据，所以它可以很好地支持这种基于区间的查询。
      2. **排序和分组**：对于需要进行排序或分组的SQL语句，B+树索引可以提供快速的查找服务，尤其是当这些操作需要在索引上进行时。
      3. **多列组合索引**：在联合索引（复合索引）中，B+树索引可以高效地处理`WHERE col1 = 'value' AND col2 = 'value2'`这样的查询。
      4. **数据量大且频繁更新的场景**：对于数据量较大且更新操作不频繁的表，使用B+树索引是合适的选择。因为B+树在插入和删除时的维护成本相对较低。

**哈希索引**
   **特点**：基于哈希表实现，只有精确匹配索引列的查询才能使用这种索引。对于非等值查询（如范围查询），Hash索引是不适用的。
   **适用场景**：
      1. **等值查询**：由于哈希索引是通过直接计算键值的哈希码来定位数据的，因此对于精确匹配的等值查询（如`WHERE col = 'value'`）速度非常快。
      2. **集合成员检查**：当需要判断某个元素是否存在于一个集合中时，哈希索引是一个高效的选择。例如，`WHERE col IN ('value1', 'value2', 'value3')`这样的查询可以使用哈希索引来加速。
      3. **唯一性校验**：在某些场景下，比如主键或者唯一约束的检查，哈希索引可以快速验证数据的唯一性。

### 组合索引（复合索引）
**特点**：由多个列组成的索引，可以覆盖一个或多个列上的查询。MySQL会自动优化组合索引的使用方式。
**适用场景**：当经常需要同时根据多个列进行查询时，使用组合索引可以显著提高查询效率。例如，对于WHERE子句中包含多个条件的查询，可以通过创建复合索引来加速。
### 覆盖索引
在MySQL中，覆盖索引（Covering Index）是指一个查询所需的全部数据都可以从索引中获取，而不需要回表到主键或聚集索引。这意味着查询的执行只需要使用索引中的列，而无需访问实际的数据行。这种情况下，MySQL可以直接从索引中获取所有所需的数据，而不需要访问实际的数据行。这种情况下，查询的执行通常非常高效，因为它避免了回表操作。
### 不用索引的场景

在大多数情况下，索引在查询中是用于提高性能的，因为它们加速了数据查找。然而，有些特殊情况下，索引的使用会导致性能下降，索引失效反而可能提升查询效率。以下是一些例子：

1. **小表查询**：
   - 对于非常小的表，MySQL可能会选择全表扫描（忽略索引），因为全表扫描的开销可能比通过索引逐行查找还要低。在这种情况下，索引失效不会损害性能，反而简化了查询。

2. **读取大部分或所有行**：
   - 当一个查询返回表中很大比例的行（如30%或更多）时，使用索引查找可能会耗时更多，因为数据库必须跳回主数据页以读取完整记录。全表扫描可能更有效，因为它可以逐行顺序读取数据。

3. **低选择性索引**：
   - 如果索引列的选择性非常低，例如一个布尔型字段，许多行有相同的值，那么依赖索引可能会产生不必要的开销。全表扫描可以避免索引的搜索和回表开销。

4. **频繁更新的表**：
   - 对于包含大量更新操作的表，索引的维护成本可能相对较高。尤其是在频繁更新索引列时，通过避免使用或减少复杂的索引可以减轻写操作的负担。

5. **复杂查询的优化选择**：
   - 对于复杂的多表联接查询，优化器有时可以选择执行计划中不使用某个索引（或部分失效）以提高整体联接和计算效率。

6. **数据分布与优化器误判**：
   - 在某些特定情况下，如果索引导致MySQL错误地估计数据分布或行数，手动禁用索引或提示优化器使用不同策略可能提升性能。

7. **SELECT 语句中对列进行运算**：
    - MySQL在进行索引选择时，会考虑查询条件中的表达式。如果查询条件中有函数或表达式（例如 `WHERE LENGTH(column) = 5`），MySQL可能会放弃使用索引。
   ```sql
   -- 不推荐
   SELECT * FROM table_name WHERE LENGTH(column) = 5;
   -- 推荐
   UPDATE column SET column = 'value' WHERE column = 'value';
   ```

8. **LIKE 查询以%开头**：
    - 当使用 `LIKE` 进行模糊查询时，如果搜索条件以通配符（如 `%`）开始，MySQL可能会放弃使用索引。
   ```sql
   -- 不推荐
   SELECT * FROM table_name WHERE column LIKE '%value';
   -- 推荐
   SELECT * FROM table_name WHERE column LIKE 'value%';
   ```

      对于需要匹配后缀的情况（即 `LIKE '%suffix'`），可以创建一个辅助列存储反转字符串，并基于此列进行前缀匹配。

      - **创建反向字符串**：

      ```sql
      ALTER TABLE users ADD reversed_username VARCHAR(255);
      UPDATE users SET reversed_username = REVERSE(username);
      CREATE INDEX idx_reversed_username ON users(reversed_username);

9. **数据类型不匹配**：
   - 如果查询条件中的列和索引列的数据类型不匹配，MySQL可能会放弃使用索引。例如，如果有一个字符串类型的索引列，但查询时将其作为数值类型使用。
   ```sql
   -- 不推荐
   SELECT * FROM table_name WHERE column = 123;
   -- 推荐
   UPDATE column SET column = 'value' WHERE column = 'value';
   ```

10. **WHERE 子句中使用OR**：
   - 当 `WHERE` 子句中有多个条件，且这些条件是用 `OR` 连接的，MySQL可能会放弃使用索引。如果可能，使用复合索引来优化这种情况。
   ```sql
   -- 不推荐
   SELECT * FROM table_name WHERE column1 = 'value' OR column2 = 'value';
   -- 推荐
   ALTER TABLE table_name ADD INDEX idx_combined (column1, column2);
   ```

11. **ORDER BY 和 GROUP BY**：
    - 当使用 `ORDER BY` 或 `GROUP BY` 时，如果查询条件中的列不在索引中，MySQL可能会放弃使用索引。
   ```sql
   -- 不推荐
   SELECT * FROM table_name ORDER BY column;
   -- 推荐
   ALTER TABLE table_name ADD INDEX idx_column (column);
   ```

### 优化索引

1. **选择合适的索引列**：
   - **选择性高的列**：选择性高的列是指该列的值唯一的可能性很高，例如主键或唯一条目。这样的列适合作为索引。
   - **频繁查询的列**：经常在WHERE子句中出现的列应该被考虑建立索引。
   - **排序和分组依据的列**：用于ORDER BY、GROUP BY以及联接条件的列也应该被索引。

2. **创建复合索引**：
   - **复合索引**：复合索引是指包含两个或更多列的索引，其顺序也影响了性能。MySQL能够使用复合索引来优化多列查询。
   - **最左前缀原则**：在复合索引中，索引列的顺序非常重要。MySQL可以利用复合索引的最左前缀来进行有效的搜索。例如，创建(col1, col2)的复合索引比单独的(col2, col1)更高效，因为MySQL能够使用col1上的索引来快速定位数据。 

3. **避免冗余索引**：
   - **识别并删除重复和冗余的索引**：如果两个独立索引的列完全相同，那么只有第一个索引会被使用。可以使用以下查询来找出冗余索引：

4. **使用合适的索引类型**：
   - **主键和唯一索引**：强制数据的唯一性，加快查找速度。
   - **普通索引**：用于提高查询性能的列上创建。
   - **全文索引**：适用于全文搜索，如在TEXT或VARCHAR列上创建。

5. **定期分析和优化索引**：
   - **检查并重建索引**：使用`ANALYZE TABLE`和`OPTIMIZE TABLE`命令来确保索引统计信息是最新的，并可能通过删除并重新创建索引来优化它们。
   - **使用工具**：可以使用MySQL的自带工具如`mysqlcheck`或者第三方的优化工具如Percona Toolkit来进行索引维护。

6. **监控和调整**：
   - **监控查询性能**：使用慢查询日志（slow query log）来找出需要优化的查询，并进行相应的索引调整。
   - **分析执行计划**：使用`EXPLAIN`关键字来分析SQL语句的执行计划，查看是否正确使用了索引。

### 联合索引&最左匹配

1. **最左匹配原则（Leftmost Prefix）**
当使用联合索引进行查询时，只要在最左边连续的列上使用了相同的值，就可以使用这个索引。例如：
- 如果你创建了一个包含`column1`和`column2`的联合索引，那么查询条件中的组合可以是：
  - `WHERE column1 = 'value'`
  - `WHERE column1 = 'value' AND column2 = 'value'`
  但是，以下情况不能使用这个索引：
  - `WHERE column2 = 'value'`（因为最左边的`column1`没有被匹配）

2. **最左匹配原则的存在有几个原因：**
   1. **优化查询性能**：对于大多数查询，只需要使用索引的前缀就可以找到所需的数据。这样可以避免全表扫描，从而提高查询效率。
   2. **节约存储空间**：如果每种可能的组合都单独建一个索引，那么索引文件会变得非常大。最左匹配原则只对最左边连续的列进行索引，节省了存储空间。
   3. **一致性**：在最左匹配原则下，查询条件的顺序是固定的，这样数据库内部可以预先优化这些条件组合，从而提高执行效率。
3. **实际应用中的例子**
假设有一个表`my_table`，包含以下列：
- `id`（主键）
- `name`
- `age`
- `city`
你可以创建一个联合索引来优化查询：
```sql
CREATE INDEX idx_name_age ON my_table(name, age);
```
这个索引允许以下类型的查询使用索引进行快速查找：
- 高效查询：
  - `SELECT * FROM my_table WHERE name = 'John' AND age = 30;`
  - `SELECT * FROM my_table WHERE name = 'John';`
- 低效查询（无法使用索引）：
  - `SELECT * FROM my_table WHERE age = 30;`

### 分析查询索引
   1. **使用 `EXPLAIN` 命令**
   `EXPLAIN` 是 MySQL 提供的一个关键字，用于解释（即展示）MySQL 如何执行一个特定的 SQL 查询。通过查看 `EXPLAIN` 的结果，你可以了解 MySQL 是如何处理你的查询的，包括是否使用了索引。

   **示例：**
   ```sql
   EXPLAIN SELECT * FROM your_table WHERE column = 'value';
   ```
   2. **使用 `SHOW INDEXES`**
   `SHOW INDEXES` 命令可以显示表的索引信息。你可以通过这个命令来检查你的表是否已经创建了所期望的索引。

   **示例：**
   ```sql
   SHOW INDEXES FROM your_table;
   ```
   3. **使用 `ANALYZE TABLE`**
   `ANALYZE TABLE` 可以更新表的统计信息，包括行数、删除的行数等。这些统计信息对于优化器选择最优查询计划非常重要。通过查看统计信息，你也可以间接了解索引的使用情况。

   **示例：**
   ```sql
   ANALYZE TABLE your_table;
   ```
   4. **使用 `SHOW TABLE STATUS`**
   `SHOW TABLE STATUS` 可以显示表的详细状态信息，包括行数、删除的行数等。通过查看这些信息，你也可以了解索引的使用情况。

   **示例：**
   ```sql
   SHOW TABLE STATUS LIKE 'your_table';
   ```
   5. **使用性能监控工具**
   MySQL 提供了一些性能监控工具，如 `mysqldumpslow`, `mysqlsla` 等，这些工具可以帮助你分析查询日志，找出低效的查询语句。

   **示例：**
   - **mysqldumpslow**: 用于分析慢查询日志。
   - **mysqlsla**: 用于分析慢查询日志和二进制日志。
   6. **使用 `CREATE INDEX`**
   如果你怀疑某个查询没有使用索引，但又不知道为什么，可以直接创建一个索引来验证效果。

   **示例：**
   ```sql
   CREATE INDEX idx_column ON your_table(column);
   ```
   7. **使用 `OPTIMIZE TABLE`**
   对于已经删除大量行或者已经更新（但没有物理上删除）的表，可以使用 `OPTIMIZE TABLE` 来整理表数据，这可能会优化查询性能。

   **示例：**
   ```sql
   OPTIMIZE TABLE your_table;
   ```
### 索引回表
**索引回表**是指在使用索引查询数据时，MySQL先通过索引定位到记录所在的物理位置，然后再根据这个位置读取实际的行数据。

例如，假设有一个表`users`，其中包含以下列：`id`, `name`, 和 `age`。如果你创建了一个复合索引（`idx_name_age`）包含`name`和`age`列，并且你执行一个查询只选择这两个字段：
```sql
SELECT name, age FROM users WHERE name = 'John' AND age = 30;
```
在这种情况下，MySQL可以使用`idx_name_age`索引来定位符合条件的记录，但由于查询只涉及`name`和`age`列，而不需要实际的行数据（即不需要读取`id`列的数据），所以它不会“回表”。
然而，如果查询中包含了未被索引覆盖的其他列，例如：
```sql
SELECT * FROM users WHERE name = 'John' AND age = 30;
```
在这种情况下，MySQL使用`idx_name_age`索引来定位记录后，仍然需要根据找到的记录位置去表中读取`id`列的数据，这就是所谓的“回表”操作。


### 索引失效
   1. **没有使用索引列进行查询**
   - **原因**：MySQL 需要扫描整个表来找到匹配的行，特别是当选择性低的列作为过滤条件时。
   - **优化方法**：确保查询使用了适当的索引列。对于单列索引，通常会选择 WHERE 子句中出现的列；对于组合索引，要使用最左前缀原则。

   2. **索引列上进行了函数操作**
   - **原因**：在进行函数操作后，索引列的值可能不再是连续存储的，导致无法有效利用索引。
   - **优化方法**：在 WHERE 子句中直接使用索引列，不要对其进行任何函数操作。例如，如果有一个索引在 `col` 上，不要写成 `WHERE TO_DAYS(col) = somevalue`，而是直接写成 `WHERE col = somevalue`。

   3. **WHERE 子句中使用了范围查询（如 `<`, `>`, `BETWEEN`, `LIKE`）**
   - **原因**：范围查询会限制索引的使用，特别是当范围发生在索引列的前面部分时，后面的部分无法使用索引。
   - **优化方法**：尽量将范围查询转换为等值查询或使用覆盖索引（尽可能在索引中包含所有需要的列）。例如，如果有一个复合索引 `(col1, col2)`，而查询是 `WHERE col1 = somevalue AND col2 > somevalue`，可以考虑添加单独的索引来优化这个查询。

   4. **使用不等于（`!=`, `<>`）操作符**
   - **原因**：不等于操作会使得索引失效，因为 MySQL 无法高效地利用索引进行范围扫描。
   - **优化方法**：尽量避免在 WHERE 子句中使用不等于操作符，可以通过其他方式来实现相同的功能，如使用 `NULL` 值判断或者分段查询。

   5. **LIKE 前缀模糊查询**
   - **原因**：对于以通配符开头的 LIKE 查询，索引也会失效。因为索引只能加速以特定字符开头或连续的字符串搜索。
   - **优化方法**：使用全文索引来处理这种类型的查询，或者在列上创建前缀索引（但要注意选择合适的前缀长度）。另外，尽量避免在 LIKE 子句中使用通配符开头的模糊查询。

   6. **数据类型不匹配**
   - **原因**：当索引列和 WHERE 子句中的条件类型不匹配时，索引无法有效使用。例如，索引列是字符串类型，而查询条件是数值类型。
   - **优化方法**：确保索引列和查询条件的类型一致，可以通过强制类型转换来实现。

   7. **表连接条件不当**
   - **原因**：当多个表进行连接时，如果关联条件没有使用索引列，MySQL 可能会放弃使用索引，转而进行全表扫描。
    **优化方法**：在连接条件中使用索引列，或者通过创建覆盖索引来减少需要回表的次数。

   8. **组合索引的使用不当**
   - **原因**：如果查询没有按照组合索引的最左前缀顺序进行，索引可能无法被有效利用。
   - **优化方法**：确保查询条件符合最左前缀原则，或者考虑创建一个适用于多种查询条件的复合索引。

   9. **数据分布不均匀**
   - **原因**：如果某些索引列的值分布非常不均匀（如只有少数几个不同的值），索引的效果会大打折扣。
   - **优化方法**：可以通过重新设计数据库结构或者增加默认值来分散数据分布。

   10. **更新频繁的列上建索引**
   - **原因**：如果一个列经常被更新，索引页可能会变得陈旧，影响查询性能。
   - **优化方法**：可以考虑定期重建或优化表，或者使用不需要经常更新的列作为索引键。

## 锁
MySQL 中的锁是一种用于管理并发访问数据库的机制。它确保在多个用户或事务同时访问和修改数据时，数据的完整性和一致性不受破坏。锁的主要作用是防止多个事务同时对同一资源进行修改，导致数据不一致或其他并发问题。
### 锁类型
   1. **共享锁（Shared Lock）/读锁（Read Lock）**：允许事务读取某一行数据。如果有其他事务已经获得了该行的共享锁，那么当前事务也可以获得该行的共享锁；如果已经有事务获取了排他锁，则当前事务不能获得共享锁。适用于以下场景：
      - 大多数读操作，特别是对于不会修改数据的查询（如SELECT语句）。
      - 在事务中执行读取操作时使用，以确保数据一致性和并发性。

   2. **排他锁（Exclusive Lock）/写锁（Write Lock）**：允许事务更新或删除某一行数据。如果有其他事务已经获得了该行的共享锁或排他锁，那么当前事务不能获得任何锁；如果已经有事务获取了排他锁，则当前事务也不能获得排他锁。适用于以下场景：
      - 写操作，特别是INSERT、UPDATE和DELETE语句。
      - 在事务中执行写入操作时使用，以确保数据一致性和并发性。
| 特性         | 共享锁（S Lock）                           | 排他锁（X Lock）                   |
| ------------ | ------------------------------------------ | ---------------------------------- |
| **定义**     | 允许读取数据，但不允许写入数据             | 完全锁定资源，既不允许读也不允许写 |
| **并发性**   | 允许多个事务同时读取（多个读操作可以并行） | 阻止其他所有事务访问（独占式访问） |
| **适用场景** | 适用于读取数据的操作                       | 适用于需要修改数据的操作           |
| **锁定范围** | 行级、表级均可                             | 行级、表级均可                     |
| **其他影响** | 不影响其他事务的读操作，但阻止写操作       | 阻止所有其他事务的读和写操作       |

   3. **意向锁（Intention Locks）**：是一种表级别的锁，用于指示某种类型的锁即将被请求。MySQL 中的意向锁主要分为两种：
      - 意向共享锁（IS Lock）：表示事务打算对表中的某些行加共享锁。
      - 意向排它锁（IX Lock）：表示事务打算对表中的某些行加排它锁。

   4. **记录锁（Record Locks）**：锁定单个行的锁，主要用于在唯一索引上进行查找时使用。

   5. **间隙锁（Gap Locks）**：锁定索引记录之间的间隔，防止其他事务在这个间隔中插入新纪录。适用于避免幻读问题。

   6. **临键锁（Next-Key Locks）**：是记录锁和间隙锁的组合，锁定一个范围并且包括记录本身。

   7. **乐观锁**：适用于高并发、读操作多的数据库应用，如博客系统、论坛等。

   8. **悲观锁**：适用于写操作多且对数据一致性要求高的场景，如银行转账、库存管理等。

### 死锁
**死锁**是指两个或多个事务在互相等待对方释放资源而造成的一种僵局。每个事务都在等待另一个事务释放其占用的资源，结果是所有涉及的事务都无法继续执行。

**原因：**
   1. **并发冲突**：当多个事务同时访问相同的数据时，可能会出现相互等待的情况。例如，事务A持有数据X的锁并请求数据的锁，而事务B也持有数据Y的锁并请求对数据Y的锁，但需要获取数据X的锁。
   2. **资源分配不当**：如果数据库在分配和释放资源时不合理，比如使用不适当的锁定机制或超时设置，可能会导致死锁。
   3. **系统设计缺陷**：系统的设计可能没有考虑到并发控制的问题，导致无法有效地避免死锁。

**如何避免：**
   1. **最小化事务范围**：尽量缩短每个事务的长度和涉及的资源数量，减少事务之间冲突的机会。
   2. **降低隔离级别**：如果应用程序不需要高级的事务隔离级别（如Serializable），可以考虑使用较低级别的隔离性来减少锁定的时间和范围。
   3. **调整锁粒度**：根据实际情况调整锁的粒度，使得在多个事务并发时，每个事务需要的资源更少，从而减少冲突的可能性。
   4. **有序处理资源请求**：确保所有事务按照相同的顺序请求资源，避免循环等待条件（例如，使用固定的锁顺序）。
   5. **超时机制**：设置合理的超时时间，当一个事务等待另一个事务释放锁超过一定时间后，当前事务可以被强制终止，以打破死锁。
   6. **定期维护和检查**：定期对数据库进行碎片整理、索引优化等操作，减少因为数据结构问题导致的死锁。
   7. **使用合适的隔离级别**：在可接受的范围内选择合适的隔离级别（如Read Committed, Repeatable Read等），以平衡并发性和隔离性的需求。
   8. **诊断工具和日志**：利用数据库提供的工具和服务监视系统状态，及时发现并解决潜在的死锁问题。





## count()

在 SQL 中，`COUNT()` 函数用于统计行的数量，不同用法的核心差异体现在统计范围、逻辑与性能上，具体如下：

**1. COUNT(1)**

- **功能**：统计所有行的数量，不区分行内值的内容。
- **工作原理**：以常数 `1` 作为计数标识，对每一行均计数一次，逻辑与 `COUNT(*)` 一致。
- **效率**：多数数据库已对其优化，性能与 `COUNT(*)` 基本等效。

**2. COUNT(*)**

- **功能**：统计所有行的数量，包含所有列，不受列值是否为 `NULL` 的影响。
- **工作原理**：按行维度统计，不依赖列的具体数据。
- **效率**：是常用且性能较优的方式（如 InnoDB 引擎会直接统计数据页数目）。

**3. COUNT(column_name)**

- **功能**：仅统计指定列中值为**非 NULL** 的行数。
- **工作原理**：遍历列中每一行，仅计数非 `NULL` 的记录。
- **适用场景**：需过滤 `NULL` 值的场景（如统计特定字段有值的记录数）。

**性能对比**

- `COUNT(*)` 与 `COUNT(1)`：现代数据库已优化，性能基本一致。
- `COUNT(column_name)`：性能相对较低（需逐行检查列值是否为 `NULL`，尤其是列中 `NULL` 较多时）。

**用法选择**

- 优先选 `COUNT(*)`：语义清晰且通常经过数据库优化。
- 选 `COUNT(column_name)`：仅当需要统计指定列非 `NULL` 值的行数时使用。

**小结**

三者的选择核心依据是**是否需要过滤 `NULL` 值**：

- 仅统计总行数：用 `COUNT(*)` 或 `COUNT(1)`（推荐 `COUNT(*)`）。
- 统计指定列非 `NULL` 行数：用 `COUNT(column_name)`。

11111111



## License

Copyright 2025-present [Ginyee-W](https://ginyee-w.github.io/).

